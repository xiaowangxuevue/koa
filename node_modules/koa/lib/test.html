<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

  'use strict'

  // var mid = [1,2,3]
  // console.log(Array.isArray(mid))  //ture
  // for(const fa of mid) {
  //   console.log(fa)
  // }
  // function compose(){
  //   console.log(123)
  //   return function (context,next) {
  //   let index = -1
  //   return dispatch(0)
  //   function dispatch (i) {
  //     if(i <= index) return Promise.reject(new Error('next called multiple times'))  
  //     index = i
  //     let fn = mid[i]   //mid中的函数从第一个开始
  //     if(i === mid.length)  fn = next  //此时fn为nuderfine
  //     if(!fn) return Promise.resolve()
      // try {
      //   return Promise.resolve(fn(context,dispatch.bind(null,i+1)));
      // }


  //   }
  // }
  // }

  //构造bind函数
  // var hello = function (a,b,c,d) {
  //   console.log('this is ')
  //   console.log(this.name);
  //   // console.log(a,b,c,d)
  // };
 
  // var h = hello.bind(demo,1,2)
  // h(3,4)
 /*  var test = function (a,b,c,d) {
    console.log(arguments)  //arguments(3) [1,2,3]
    console.log(a,b,c,d)
  };
  test(1,2,3)  //argments把传入数组的参数整理成一个类数组对象
 */
  console.log(this,'this10')
  var demo = {
  name:'demo'
  }
  // Function.prototype.myBind = function() {
  //  // 保存bind传入进来的第一个参数
  //   const params_first = arguments[0]  //demo{}
  //  // 把bind传入的第2,3,4...等参数保存进来
  //   const arg = []  //1,2
  //   for (let i = 1;i < arguments.length; i++) {
  //     arg.push(arguments[i])
  //   }
  //   console.log(arg,'arg')
  //   // this指向第一个参数，把原函数绑定成该参数的一个属性即可
  //   params_first.tempUniqueFunction = this
  //   console.log(params_first.tempUniqueFunction,'params_first.tempUniqueFunction')
  //   console.log(params_first,'params_first')
  //   return function () {
  //     for (let i = 0 ;i <  arguments.length; i++) {
  //       arg.push(arguments[i])
  //     }
  //     console.log(...arg,'arg')
  //     const newFunction = params_first.tempUniqueFunction(...arg)
  //     // 不要凭空给参数添加属性，所以用完我们还得删除，因此用newFuncrion保存了新的this指向函数
  //     delete params_first.tempUniqueFunction
  //     return newFunction
  //   }
  // }

    Function.prototype.myBind = function() {
      // 保存bind传入进来的第一个参数
    
      const params_first = arguments[0]
      const arg = []
      for(let i = 0;i < arguments.length; i++) {
        arg.push(arguments[i])
      }
      params_first.tempUniqueFunction = this
      return function() {
        for(let i =0; i< arguments.length;i++) {
          arg.push(arguments[i])
        }
        const newFunction = params_first.tempUniqueFunction(...arg)
        delete params_first.tempUniqueFunction
        return newFunction
      }
    }

  var hello = function(a,b,c,d) {
    console.log(this.name)
    console.log(arguments)
    console.log(this,'this is')
  };
  console.log(demo)
  hello.myBind(demo,1,2)(3,4)

































  </script>
</body>
</html>