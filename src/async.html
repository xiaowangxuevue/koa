<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>








   //async 
  //  async function fun0() {
  //    console.log(1,'one');
  //    return function fun3(){
  //      return 4
  //    };
  //  }
  //  fun0().then(val=>{
  //    console.log('val is',val())
  //  })

  //  async function fun1(){
  //    console.log('2','two');
  //    return new Promise(function(resolve,reject){
  //      resolve('Promisep')
  //    })
  //  }
  //  fun1().then(val => {
  //    console.log(val)
  //  })
  // async function fun() {
  //   let a = 1;
  //   let b = await new Promise((resolve,reject)=>{
  //     setTimeout(function(){
  //       resolve('setTimeout')
  //     },2000)
  //   })  
  //   let c= await function() {
  //     return 'function'
  //   }()
  //   console.log(a)
  // }
  // fun()

  // function log(time){
  //   setTimeout(function(){
  //     console.log(time)
  //   },time)
  // }
  // async function fun(){
  //   let a = await log(1000);
  //   let b = await log(3000);
  //   let c = log(2000);
  //   console.log(a);
  //   console.log(1)

  // }
  // fun();
//await 也是一个修饰符，只能放在async定义的函数内。可以理解为等待。

/* await 修饰的如果是Promise对象：可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；

如果不是Promise对象：把这个非promise的东西当做await表达式的结果。
 */
 

  // function getSomeThing() {
  //   return new Promise((resolve,reject) => {
  //     setTimeout(() => {
  //       resolve('获取成功')
  //     },3000)
  //   })
  // }


  // async function test() {
  //   let a = await getSomeThing();
  //   console.log(a)
  // }
   
   
  // test();
  const animals = ['aa','bb','cc','dd','ee'];
  console.log(animals.slice(2,4));  //不包括4

  









  

 
  function bind(fn, context) {
  var args = Array.prototype.slice.call(arguments, 2);
  return function() {
    var fnArgs = Array.prototype.slice.call(arguments);
    console.log(fnArgs,'fn123')
    return fn.apply(context, args.concat(fnArgs));
  };
}

const person = {
  name: "John",
  age: 30
};

const boundFunc = bind(
  (greeting) => {
    console.log(greeting + ", my name is " + this.name);
  },
  person,
  "hello"
);

boundFunc();

























  </script>
</body>
</html>